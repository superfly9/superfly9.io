---
category: "dev"
title: "closure"
preview: ""
date: "2025-08-15T15:10:23.000Z"
author:
  name: 승찬
  picture: "/assets/blog/authors/jj.jpeg"
coverImage: "/assets/blog/preview/cover.jpg"
---

ThemeScript에서 updateDOM이 클로저

요약

클로저의 정의:
  외부 함수의 변수에 접근할 수 있는 내부 함수

  - updateDOM은 외부 스코프의 storageKey와 applyMode에 접근
  - applyMode는 자신이 정의된 스코프 내의 변수만 사용 (클로저 아님)


```jsx
  (function () {  // ← IIFE (즉시 실행 함수)
    const [DARK, LIGHT] = ["dark", "light"];  // ← 외부 스코프 변수
    const storageKey = "theme";

    function applyMode(mode) {  // ← 클로저 함수
      // DARK, LIGHT, storageKey에 접근 가능 (렉시컬 스코프)
      const resolvedMode = mode === 'dark' ? 'dark' : 'light';
      // ...
    }

    // applyMode가 외부 변수들을 "기억"함
  })()  // ← 즉시 실행
```
  클로저의 특징:
  - applyMode는 외부 함수의 변수들(DARK, LIGHT, storageKey)에 접근
  - IIFE가 끝나도 applyMode는 이 변수들을 "기억"
  - 전역 네임스페이스 오염을 방지하면서도 필요한 변수에 접근 가능

  -> updateDOM이 applyMode를 참조하고 있어서 클로저가 형성

  (function () {
    const storageKey = "theme";

    function applyMode(mode) {  // ← 내부 함수
      // ...
    }

    // updateDOM이 applyMode를 참조 → 클로저 형성
    window.updateDOM = () => {
      const mode = localStorage.getItem(storageKey) === 'dark' ? 'dark' : 'light';
      applyMode(mode);  // ← applyMode를 계속 참조
    };
  })()  // IIFE 실행 완료

  클로저가 형성되는 이유:
  1. IIFE가 실행 완료되면 보통 내부 변수들(storageKey, applyMode)은 메모리에서 해제되어야 함
  2. 하지만 window.updateDOM이 applyMode를 참조하고 있음
  3. JavaScript 엔진이 "아직 사용중이구나"하고 applyMode와 그 안에서 참조하는 변수들을 메모리에 유지
  4. 결과적으로 updateDOM이 호출될 때마다 applyMode와 storageKey에 접근 가능

  실제로:
  // 나중에 다른 곳에서 호출 가능
  window.updateDOM();  // applyMode가 여전히 살아있음

  외부 함수가 종료되어도 내부 함수가 외부 변수를 "기억"
  - applyMode: 사용안하는 클로저(외부 변수 접근 가능하지만 실제 사용은 안 함)
  - updateDOM: 사용하는 클로저(외부 스코프의 storageKey, applyMode를 참조하고 실제로 사용)


